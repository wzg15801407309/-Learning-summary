# C 语言学习

## C 语言基本语法

1. 语句：语句必须使用分号结尾，除非有明确规定可以不写分号。

```C
 int x = 1; // 语句
 int x; x = 1; // 多行语句
```

2. 表达式：C 语言的各种计算，主要通过表达式完成。表达式（expression）是一个计算式，用来获取值。
   > 1 + 2 // 表达式
   > 1 + 2； // 表达式+分号 = 语句 实际无用
3. 语句块：C 语言允许多个语句使用一对大括号{}，组成一个块，也称为复合语句（compounded statement）。
4. 空格：知道：语法单位之间的多个空格，等同于单个空格
5. printf(): 输出函数 标准库文件 stdio.h
   > 特点一：手动添加换行 \n 换行
   > 特点二：占位符 %i == int %s == char

## 变量

- 注意：** 变量的作用域**
  > C 语言的变量作用域主要有两种：文件作用域（file scope）和块作用域（block scope）。

## 运算符 ：<< 左移运算符 >> 右移运算符（二进制位）

## 流程控制：goto 不建议使用

## 数据类型【**重点**】

- 1. 字符类型，类型声明使用：char 关键字。
     》**C 语言规定，字符常量必须放在【单引号】里面。**
     》**字符类型使用一个字节（8 位）存储**
- 2. 整数类型，类型声明使用： int 关键字。
     - 2.1 注意的点
       》**4 个字节（32 位）存储一个 int 类型的值**
       》**signed 关键字表示带有正负号**
       》**unsigned 不带符号**
       》**C 语言的头文件 limits.h 提供了相应的常量，系统不同整数类型的最大值和最小值**
     - 2.2 整数的子类型
       》short int（简写为 short）：占用空间不多于 int，一般占用 2 个字节（整数范围为-32768 ～ 32767)。
       》long int（简写为 long）：占用空间不少于 int，至少为 4 个字节。
       》long long int（简写为 long long）：占用空间多于 long，至少为 8 个字节。
     - 2.3 整数的紧制
       》**八进制使用 0 作为前缀**
       》**十六进制使用 0x 或 0X 作为前缀**  
       》**十六进制使用 0x 或 0X 作为前缀**
       > %d：十进制整数。 %o：八进制整数。 %x：十六进制整数。
       > %#o：显示前缀 0 的八进制整数。 %#x：显示前缀 0x 的十六进制整数。 %#X：显示前缀 0X 的十六进制整数。
- 3. 浮点数，类型声明使用： float 关键字。
     》**4 个字节（32 位）存储一个 float 类型的值**
     》**更大的浮点数：(1)double：占用 8 个字节（64 位）(2)long double：通常占用 16 个字节。**
- 4. 布尔类型: bool （最初：C 语言没有单独的类型表示布尔类型 C99 标准添加了类型\_Bool，表示布尔值）
     》**所有非零值表示真。0 表示伪，1 表示真**
     》**头文件 stdbool.h 定义了另一个类型别名 bool，并且定义了 true 代表 1、false 代表 0。只要加载这个头文件，就可以使用这几个关键字。**

- 5. 字面量的类型 理解：直接给变量赋值的语句 被称为字面量
- 8. 益出 理解：大于最大值，叫做向上溢出（overflow）；小于最小值，叫做向下溢出（underflow）。 编译器不会对溢出报错，会正常执行代码，但是会忽略多出来的二进制位
- 9. sizeof 运算符
     > sizeof 是 C 语言提供的一个运算符，返回某种数据类型或某个值占用的字节数量。它的参数可以是数据类型的关键字，也可以是变量名或某个具体的值。
     > C 语言提供了一个解决方法，创造了一个类型别名 size_t
     > printf()有专门的占位符%zd 或%zu，用来处理 size_t 类型的值。
- 10. 类型的自动转换

      - 10.1 类型转换
        》浮点数赋值给整数变量 直接丢弃小数部分
        》整数赋值给浮点数变量 变成浮点数 .0
        》窄类型赋值给宽类型 变成宽类型，宽类型赋值给窄类型 变成窄类型。
      - 10.2 混合类型的运算 【**不同类型的值进行混合计算时，必须先转成同一个类型，才能进行计算**】
        》转换规则是：
        > 1）整数与浮点数混合运算时，整数转为浮点数类型。
        > 2）不同的浮点数类型混合运算时，宽度较小的类型转为宽度较大的类型
        > 3）整数类型的运算 结果为整数

- 11. 类型的显式转换 推荐 (强制要换的类型)

## 指针【**重点**】

- 1.  简介

* 1.1 字符\*表示指针
* 1.2 **‘\*’**这个符号除了表示指针以外，还可以作为运算符，用来取出指针变量所指向的内存地址里面的值。
* 1.3 &运算符用来取出一个变量所在的内存地址

- 2. 指针变量的初始化
     > **正确做法：**是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。
     > **注意：** NULL 在 C 语言中是一个常量，表示地址为 0 的内存空间，这个地址是无法使用的，读写该地址会报错。

```C
int* p;
int i;
// &i 取i变量的内存地址
p = &i;
*p = 13;
```

- 3. 指针的运算

* 3.1 指针与整数值的加减运算
  > 指针与整数值的运算，表示指针的移动。

```C
short* j;
j = (short*)0x1234;
j = j + 1; // 0x1236
```

> 原因是 j + 1 表示指针向内存地址的高位移动一个单位，而一个单位的 short 类型占据两个字节的宽度，所以相当于向高位移动两个字节。同样的，j - 1 得到的结果是 0x1232。

- 注意：**指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。**

* 3.2 指针与指针的加法运算 【指针只能与整数值进行加减运算，两个指针进行加法是非法的】
* 3.3 指针与指针的减法
  > 相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。
  > 高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。
  > 这时，减法返回的值属于 ptrdiff_t 类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件 stddef.h 里面。

```C
short* j1;
short* j2;

j1 = (short*)0x1234;
j2 = (short*)0x1236;

ptrdiff_t dist = j2 - j1;
printf("%td\n", dist); // 1
```

- 3.4 指针与指针的比较运算
  > 指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数 1（true）或 0（false）。
- 4.  函数
      》4.1 函数：
      （1）返回值类型。函数声明时，首先需要给出返回值的类型，
      （2）参数。函数名后面的圆括号里面，需要声明参数的类型和参数名，
      （3）函数体。函数体要写在大括号里面，后面（即大括号外面）不需要加分号。大括号的起始位置，可以跟函数名在同一行，也可以另起一行，本书采用同一行的写法。
      （4）return 语句。return 语句给出函数的返回值，程序运行到这一行，就会跳出函数体，结束函数的调用。如果函数没有返回值，可以省略 return 语句，或者写成 return;。
      **注意：**不返回值的函数，使用 void 关键字表示返回值的类型。没有参数的函数，声明时要用 void 关键字表示参数类型。
      》4.2main()函数： C 语言规定，main()是程序的入口函数，即所有的程序一定要包含一个 main()函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。
      》4.3 参数的传值引用 如果函数的参数是一个变量，那么调用时，传入的是这个变量的值的拷贝，而不是变量本身。
      》4.4 函数指针 函数本身就是一段内存里面的代码，C 语言允许通过指针获取函数。
      》4.5 exit()函数： exit()函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件 stdlib.h 里面
      (1) 在 main()函数里面，exit()等价于使用 return 语句;
      》**4.6 函数说明符**
      （1）extern 说明符：对于多文件的项目，源码文件会用到其他文件声明的函数。这时，当前文件里面，需要给出外部函数的原型，并用 extern 说明该函数的定义来自其他文件。
      （2）static 说明符：static 用于函数内部声明变量时，表示该变量只需要初始化一次，不需要在每次调用时都进行初始化。也就是说，它的值在两次调用之间保持不变。
      a. **注意**:static 修饰的变量初始化时，只能赋值为常量，不能赋值为变量。

      ```C
      int i = 3;
      static int j = i; // 错误
      ```

      b. **注意**:在块作用域中，static 声明的变量有默认值 0。

      ```C
      static int foo;
      // 等同于
      static int foo = 0;
      ```

      c. **注意**:static 可以用来修饰函数本身。

      ```C
      static int Twice(int num) {
      int result = num \* 2;
      return(result);
      }
      ```

      d. **注意**:static 也可以用在参数里面，修饰参数数组。

  (3）const 说明符:函数参数里面的 const 说明符，表示函数内部不得修改该参数变量
  》**4.6 可变参数**:有些函数的参数数量是不确定的，声明函数的时候，可以使用省略号...表示可变数量的参数。
  注意，...符号必须放在参数序列的结尾，否则会报错。

## 数组【**重点**】

- 简介
  数组是一组相同类型的值，按照顺序储存在一起。数组通过变量名后加方括号表示，方括号里面是数组的成员数量。
  【**注意**】：声明数组时，必须给出数组的大小。
  【**注意**】：如果引用不存在的数组成员（即越界访问数组），并不会报错，所以必须非常小心。
- 定义
  数组也可以在声明时，使用大括号，同时对每一个成员赋值。

  > int a[5] = {22, 37, 3490, 18, 95};
  > 【**注意**】：使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。
  > 使用大括号赋值时，大括号里面的值不能多于数组的长度，否则编译时会报错。
  > 如果大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为 0。
  > 数组初始化时，可以指定为哪些位置的成员赋值。 int a[15] = {[9] = 7, [14] = 48, [2] = 29};
  > C 语言允许省略方括号里面的数组成员数量，这时将根据大括号里面的值的数量，自动确定数组的长度。

  ```C
  int a[] = {22, 37, 3490};
  // 等同于
  int a[3] = {22, 37, 3490};
  ```

- 数组的长度： 使用 sizeof 运算符会返回整个数组的**字节长度**
- 其它数组：多维数组、变长数组【数组声明的时候，数组长度除了使用常量，也可以使用变量。这叫做变长数组（variable-length array，简称 VLA）。】
- 数组的地址
  》明白：数组是一连串**连续储存**的**同类型值**，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。
  【**注意**】：数组名等同于起始地址
  【**注意**】：数组名指向的地址是不能更改的。

  ```C
  int a[5] = {11, 22, 33, 44, 55};
  int* p = &a[0];
  // 等同于
  int* p = a;
  ```

  > 这样的话：数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。函数接受数组作为参数，函数原型可以写成下面这样。

  ```C
  // 写法一
  int sum(int arr[], int len);
  // 写法二
  int sum(int* arr, int len);
  ```

- 数组指针的加减法：

1. 数组名可以进行加法和减法运算
   > 等同于在数组成员之间前后移动，即从一个成员的内存地址移动到另一个成员的内存地址。a + 1 返回下一个成员的地址，a - 1 返回上一个成员的地址。
2. 数组名与指针是等价的，所以下面的等式总是成立。
   > a[b] == \*(a + b)
3. 指针变量 p 指向数组的一个成员，那么 p++就相当于指向下一个成员，这种方法常用来遍历数组。

```C
int a[] = {11, 22, 33, 44, 55, 999};

int* p = a;

while (*p != 999) {
  printf("%d\n", *p);
  p++;
}
// 需要注意的是：不能直接a++ 因为数组的值是不能改变地址的。所以要定义一个a的地址赋值给指针变量p，然后对p进行自增。
```

4. 数组的复制
   由于数组名是指针，所以复制数组不能简单地复制数组名。

```C
int* a;
int b[3] = {1, 2, 3};
a = b;
// 上面的写法，结果不是将数组b复制给数组a，而是让a和b指向同一个数组。
// 下面才是复制操作
for (i = 0; i < N; i++){
  a[i] = b[i];
}
// 另一种方法是使用memcpy()函数（定义在头文件string.h）
memcpy(a, b, sizeof(b));
```

## 字符串【**重点**】
